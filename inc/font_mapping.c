/* 
 *
 * EMF files can contain weird "encoding".
 * This file handles one of those:
 * if ETO_GLYPH_INDEX is set in *TEXTOUT options,
 * the encoding of a char is basically the index 
 * of its corresponding glyph inside the font ttf file.
 *
 * That's great... Thanks a lot Microsoft for this crappy scheme.
 *
 * To handle this case, we define some constant mapping tables
 * (index of glyph -> unicode) of some well known fonts like Arial.
 *
 * These mapping are generated by goodies/mapping_builder.pl "<font>.ttf" 
 * which parse ttf file cmap section to build a reverse mapping.
 *
 */

#define FONT_MAPS_COL_SIZE sizeof(font_maps) / sizeof(struct cmap_collection) 

struct cmap_collection {
    char *font_name;
    size_t size;
    const uint32_t *uni;
};

// Mappings Table START

const uint32_t emf2svg_empty_font[] = {
0x0000, 0x0000, 0x0000
};

const struct cmap_collection font_maps[] = {
{"DEFAULT", 3, emf2svg_empty_font},
// Mappings Collection START
{"empty", 3, emf2svg_empty_font},
// Mappings Collection END
};
